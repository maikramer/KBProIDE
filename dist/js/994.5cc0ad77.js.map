{"version":3,"file":"js/994.5cc0ad77.js","mappings":"iKAAA,SACEA,gBAAiB,SAASC,EAAWC,GACnC,IAIIC,EAAUC,EACVC,EALAC,EAAkBL,EAAUM,OAC5BC,EAAO,GACTC,EAAO,GACPC,EAAO,GAGT,IAAKL,EAAI,EAAGA,EAAI,IAAKA,IACnBG,EAAKH,GAAS,KAAJA,EACVI,EAAKJ,GAAS,KAAJA,EACVK,EAAKL,GAAS,IAAJA,EAGZ,IAAKA,EAAI,EAAGA,GAAKC,EAAiBD,GAAK,EACrCJ,EAAUI,GAAKM,KAAKC,MAAMJ,EAAKP,EAAUI,IAAMI,EAAKR,EAAUI,EAAI,IAChEK,EAAKT,EAAUI,EAAI,KAEvB,IAAK,IAAIQ,EAAe,EAAGA,GAC3BP,EAAiBO,GAAgB,EAE/BV,EAAWF,EAAUY,GAAgB,IACjC,EACA,IACJT,EAAMO,KAAKC,OAAOX,EAAUY,GAAgBV,GAAY,IACxDF,EAAUY,EAAe,EAAQ,GAAKV,EACtCF,EAAUY,EAAe,EAAQ,IAAY,EAANT,EACvCH,EAAUY,EAAe,EAAIX,EAAI,IAAY,EAANE,EACvCH,EAAUY,EAAe,EAAIX,EAAI,IAAY,EAANE,EACvCH,EAAUY,EAAe,EAAIX,EAAI,IAAY,EAANE,EAEvCH,EAAUY,EAAe,GAAKZ,EAAUY,EACxC,GAAKZ,EAAUY,GAEjB,OAAOZ,CACT,EACAa,UAAW,SAASC,GAClB,IAAIC,EAEJ,GADAC,QAAQC,IAAI,yBAADC,OAA0BJ,IACjC,2BAA2BK,KAAKL,GAMlC,OALAC,EAAID,EAAIM,UAAU,GAAGC,MAAM,IACX,GAAZN,EAAET,SACJS,EAAI,CAACA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,GAAIA,EAAE,KAEvCA,EAAI,KAAOA,EAAEO,KAAK,IACX,CAAEP,GAAK,GAAM,IAAMA,GAAK,EAAK,IAAS,IAAJA,GAEzCC,QAAQO,MAAM,GAADL,OAAIJ,EAAG,gBAExB,E","sources":["webpack://kbide/./src/engine/utils/blockly.js"],"sourcesContent":["export default {\n  floyd_steinberg: function(imageData, w) {\n    var imageDataLength = imageData.length;\n    var lumR = [],\n      lumG = [],\n      lumB = [];\n    var newPixel, err;\n    var i;\n    for (i = 0; i < 256; i++) {\n      lumR[i] = i * 0.299;\n      lumG[i] = i * 0.587;\n      lumB[i] = i * 0.110;\n    }\n    // Greyscale luminance (sets r pixels to luminance of rgb)\n    for (i = 0; i <= imageDataLength; i += 4) {\n      imageData[i] = Math.floor(lumR[imageData[i]] + lumG[imageData[i + 1]] +\n        lumB[imageData[i + 2]]);\n    }\n    for (let currentPixel = 0; currentPixel <=\n    imageDataLength; currentPixel += 4) {\n      // threshold for determining current pixel's conversion to a black or white pixel\n      newPixel = imageData[currentPixel] < 150\n        ? 0\n        : 255;\n      err = Math.floor((imageData[currentPixel] - newPixel) / 23);\n      imageData[currentPixel + 0 * 1 - 0] = newPixel;\n      imageData[currentPixel + 4 * 1 - 0] += err * 7;\n      imageData[currentPixel + 4 * w - 4] += err * 3;\n      imageData[currentPixel + 4 * w - 0] += err * 5;\n      imageData[currentPixel + 4 * w + 4] += err * 1;\n      // Set g and b values equal to r (effectively greyscales the image fully)\n      imageData[currentPixel + 1] = imageData[currentPixel +\n      2] = imageData[currentPixel];\n    }\n    return imageData;\n  },\n  hexToRgbA: function(hex) {\n    var c;\n    console.log(`hexToRgbA called with ${hex}`);\n    if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {\n      c = hex.substring(1).split(\"\");\n      if (c.length == 3) {\n        c = [c[0], c[0], c[1], c[1], c[2], c[2]];\n      }\n      c = \"0x\" + c.join(\"\");\n      return [(c >> 16) & 255, (c >> 8) & 255, c & 255];\n    } else {\n      console.error(`${hex} is invalid.`);\n    }\n  }\n};\n"],"names":["floyd_steinberg","imageData","w","newPixel","err","i","imageDataLength","length","lumR","lumG","lumB","Math","floor","currentPixel","hexToRgbA","hex","c","console","log","concat","test","substring","split","join","error"],"sourceRoot":""}